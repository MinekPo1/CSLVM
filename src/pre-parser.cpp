#pragma once
#include <string>
#include <map>


// using an enum allows the usage of a jump table
enum Instruction {
	I_unknown,
	I_ldi,
	I_loadAtVar,
	I_storeAtVar,
	I_jts,
	I_ret,
	I_addWithVar,
	I_subWithVar,
	I_mulWithVar,
	I_divWithVar,
	I_bitwiseLsfWithVar,
	I_bitwiseRsfWithVar,
	I_bitwiseAndWithVar,
	I_bitwiseOrWithVar,
	I_modWithVar,
	I_print,
	I_println,
	I_jmp,
	I_jt,
	I_jf,
	I_boolAndWithVar,
	I_boolOrWithVar,
	I_boolEqualWithVar,
	I_largerThanOrEqualWithVar,
	I_smallerThanOrEqualWithVar,
	I_boolNotEqualWithVar,
	I_smallerThanWithVar,
	I_largerThanWithVar,
	I_putPixel,
	I_putLine,
	I_putRect,
	I_setColor,
	I_clg,
	I_done,
	I_malloc,
	I_round,
	I_floor,
	I_ceil,
	I_cos,
	I_sin,
	I_sqrt,
	I_atan2,
	I_mouseDown,
	I_mouseX,
	I_mouseY,
	I_sleep,
	I_drawText,
	I_loadAtVarWithOffset,
	I_storeAtVarWithOffset,
	I_isKeyPressed,
	I_createColor,
	I_charAt,
	I_sizeOf,
	I_contains,
	I_join,
	I_setStrokeWidth,
	I_inc,
	I_dec,
	I_graphicsFlip,
	I_newLine,
	I_ask,
	I_setCloudVar,
	I_getCloudVar,
	I_indexOfChar,
	I_goto,
	I_imalloc,
	I_getValueAtPointer,
	I_setValueAtPointer,
	I_runtimeMillis,
	I_free,
	I_getVarAddress,
	I_setVarAddress,
	I_copyVar,
	I_incA,
	I_decA,
	I_arrayBoundsCheck,
	I_getValueAtPointerOfA,
	I_stackPushA,
	I_stackPopA,
	I_stackPush,
	I_stackPop,
	I_stackPeekA,
	I_stackPeek,
	I_stackInc,
	I_stackDec,
	I_stackAdd,
	I_stackSub,
	I_stackMul,
	I_stackDiv,
	I_stackBitwiseLsf,
	I_stackBitwiseRsf,
	I_stackBitwiseAnd,
	I_stackBitwiseOr,
	I_stackMod,
	I_stackBoolAnd,
	I_stackBoolOr,
	I_stackBoolEqual,
	I_stackLargerThanOrEqual,
	I_stackSmallerThanOrEqual,
	I_stackNotEqual,
	I_stackSmallerThan,
	I_stackLargerThan,
	I_conditionalValueSet,
	I_MAX // used to determine the number of instructions. must be last.
};

std::map<std::string,Instruction> instruction_map = {
	{"ldi",I_ldi},
	{"loadAtVar",I_loadAtVar},
	{"storeAtVar",I_storeAtVar},
	{"jts",I_jts},
	{"ret",I_ret},
	{"addWithVar",I_addWithVar},
	{"subWithVar",I_subWithVar},
	{"mulWithVar",I_mulWithVar},
	{"divWithVar",I_divWithVar},
	{"bitwiseLsfWithVar",I_bitwiseLsfWithVar},
	{"bitwiseRsfWithVar",I_bitwiseRsfWithVar},
	{"bitwiseAndWithVar",I_bitwiseAndWithVar},
	{"bitwiseOrWithVar",I_bitwiseOrWithVar},
	{"modWithVar",I_modWithVar},
	{"print",I_print},
	{"println",I_println},
	{"jmp",I_jmp},
	{"jt",I_jt},
	{"jf",I_jf},
	{"boolAndWithVar",I_boolAndWithVar},
	{"boolOrWithVar",I_boolOrWithVar},
	{"boolEqualWithVar",I_boolEqualWithVar},
	{"largerThanOrEqualWithVar",I_largerThanOrEqualWithVar},
	{"smallerThanOrEqualWithVar",I_smallerThanOrEqualWithVar},
	{"boolNotEqualWithVar",I_boolNotEqualWithVar},
	{"smallerThanWithVar",I_smallerThanWithVar},
	{"largerThanWithVar",I_largerThanWithVar},
	{"putPixel",I_putPixel},
	{"putLine",I_putLine},
	{"putRect",I_putRect},
	{"setColor",I_setColor},
	{"clg",I_clg},
	{"done",I_done},
	{"malloc",I_malloc},
	{"round",I_round},
	{"floor",I_floor},
	{"ceil",I_ceil},
	{"cos",I_cos},
	{"sin",I_sin},
	{"sqrt",I_sqrt},
	{"atan2",I_atan2},
	{"mouseDown",I_mouseDown},
	{"mouseX",I_mouseX},
	{"mouseY",I_mouseY},
	{"sleep",I_sleep},
	{"drawText",I_drawText},
	{"loadAtVarWithOffset",I_loadAtVarWithOffset},
	{"storeAtVarWithOffset",I_storeAtVarWithOffset},
	{"isKeyPressed",I_isKeyPressed},
	{"createColor",I_createColor},
	{"charAt",I_charAt},
	{"sizeOf",I_sizeOf},
	{"contains",I_contains},
	{"join",I_join},
	{"setStrokeWidth",I_setStrokeWidth},
	{"inc",I_inc},
	{"dec",I_dec},
	{"graphicsFlip",I_graphicsFlip},
	{"newLine",I_newLine},
	{"ask",I_ask},
	{"setCloudVar",I_setCloudVar},
	{"getCloudVar",I_getCloudVar},
	{"indexOfChar",I_indexOfChar},
	{"goto",I_goto},
	{"imalloc",I_imalloc},
	{"getValueAtPointer",I_getValueAtPointer},
	{"setValueAtPointer",I_setValueAtPointer},
	{"runtimeMillis",I_runtimeMillis},
	{"free",I_free},
	{"getVarAddress",I_getVarAddress},
	{"setVarAddress",I_setVarAddress},
	{"copyVar",I_copyVar},
	{"incA",I_incA},
	{"decA",I_decA},
	{"arrayBoundsCheck",I_arrayBoundsCheck},
	{"getValueAtPointerOfA",I_getValueAtPointerOfA},
	{"stackPushA",I_stackPushA},
	{"stackPopA",I_stackPopA},
	{"stackPush",I_stackPush},
	{"stackPop",I_stackPop},
	{"stackPeekA",I_stackPeekA},
	{"stackPeek",I_stackPeek},
	{"stackInc",I_stackInc},
	{"stackDec",I_stackDec},
	{"stackAdd",I_stackAdd},
	{"stackSub",I_stackSub},
	{"stackMul",I_stackMul},
	{"stackDiv",I_stackDiv},
	{"stackBitwiseLsf",I_stackBitwiseLsf},
	{"stackBitwiseRsf",I_stackBitwiseRsf},
	{"stackBitwiseAnd",I_stackBitwiseAnd},
	{"stackBitwiseOr",I_stackBitwiseOr},
	{"stackMod",I_stackMod},
	{"stackBoolAnd",I_stackBoolAnd},
	{"stackBoolOr",I_stackBoolOr},
	{"stackBoolEqual",I_stackBoolEqual},
	{"stackLargerThanOrEqual",I_stackLargerThanOrEqual},
	{"stackSmallerThanOrEqual",I_stackSmallerThanOrEqual},
	{"stackNotEqual",I_stackNotEqual},
	{"stackSmallerThan",I_stackSmallerThan},
	{"stackLargerThan",I_stackLargerThan},
	{"conditionalValueSet",I_conditionalValueSet},
};


struct InstructionStorage {
	Instruction * i_codes;
	std::string * values;
	size_t size;

	InstructionStorage(std::string *i_values, size_t i_size){
		i_codes = new Instruction[i_size];
		values = new std::string[i_size];
		size = i_size;
		for (size_t i = 0; i < size; i++) {
			values[i] = i_values[i];
			i_codes[i] = I_unknown;
		}
	}

	size_t get_size(){
		return size;
	}

	Instruction get_at(size_t i){
		if(i_codes[i])
			return i_codes[i];
		return i_codes[i] = instruction_map[values[i]];
	}
};
